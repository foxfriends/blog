---
title: Models are not data structures
subtitle: You knew this already
date: 2023-01-13
tags:
- architecture
- databases
author: Cam
---

When building an app that manipulates data (e.g. a web server) we typically
interact with that data in three ways:
*   As raw data in memory or database
*   Manipulating via specific behaviours through code
*   Sending it to other applications via external APIs

If your instinct tells you that "this is the job for a model", then your instinct
is wrong. But I know you know better than that. The three seaprate tasks should be
seen as a hint that three separate pieces are required:
*   The **structure** is the base data representation
*   The **model** is for managing behaviours in code
*   The **serialization** is how we send it between applications

If you've worked on any decently sized project, you have almost certainly
been given an ORM, and your framework lets you define (what they call) "models"
which provide access to the ORMs methods, upon which you build your app.
Mistake.

Asked what ORM stands for, is your answer "Object Relational Mapping"? Notably,
the M does not stand for model, because an ORM does not (should not?) have a concept
of "model". It's simply a __mapping__ of __objects__ to a __relational__ database.
Providing convenient methods for sending data to the database, *an ORM is
a serializer*. Meanwhile, the objects you've created are an implementation of a
data structure.

This is all fine as it is until your framework convinces that you this data structure
is called a "model" and you should implement behaviours on it. Now we've merged
all three layers into a single messy lump, and your app spirals out of control
after that. This is the part we must avoid.

## The Business Object

Before getting too deep into the code side, it's worth identifying what a
"business object" might refer to: this is the thing that your non-developer
boss knows about.

If you're making a social network, a post is a likely business object.
To the boss, posts have text content and images, users react and comment
on posts, and those comments in turn have text and images, and further
comments and reactions.

If you're making an ecommerce shop, you have products. Products have names
and descriptions, each product may have a few variants, each variant may
have a different price in different countries, and there are reviews on each
variant as well. Each variant also has inventory which may exist in multiple
locations, and needs to increase and decrease as people make and cancel orders.

The business object is very high-level and, as you might have noticed already,
*has little bearing on the structure of the code*. Code will need post, reaction,
like, and share to each be distinct entities, as will product, variant, price,
review, inventory levels, and orders.

We aim to keep this bearing of business object on code structure as small as
possible.

## The Structure

Probably the most core piece of this whole puzzle is the structure. A good
data structure makes everything easy; easy to implement behaviours on
the model and easy to serialize the data (often it can be done purely
structurally).

This is also the most often overlooked layer because it's boring and
feels "low level", a scary place for those of us who are used to just
building web apps. Rather than designing features from the data-level
up, we go from model-level down.

In some cases, the model first approach doesn't go too wrong. Setting up
users and login for example is pretty straight forward:

```python
class User(Structure):
    username: str
    email: str
    password_hash: str
```

Meanwhile, if we wanted to represent posts and comments, we might consider
the needs of our model and design this structure:

```python
class Post(Structure):
    author: User
    content: str
    image_url: str
    reactions: list[Reaction]
    comments: list[Comment]


class Comment(Structure):
    author: User
    content: str
    image_url: str
    reactions: list[Reaction]
    comments: list[Comment]


class Reaction(Structure):
    user: User
    react_emoji: str
```

Sadly, this structure is lacking in a few ways. Firstly, there is
no way to consider a post without also considering its comments, author, and
reactions as well.

Secondly, and more noticeably, the nested shape does not map well
to a (relational) database. That should be the hint. In
this case, we can attempt to do the usual obvious transformation,
but quickly notice that things are not as they seem: comments can
be on posts or other comments, so we have two potential foreign
keys. Alternatively, we could support comments only to a specific
depth, but of course that's not acceptable, so we go with something
like this:

```python
class Post(Structure):
    author_id: int
    content: str
    image_url: str


class Comment(Structure):
    post_id: int | None
    comment_id: int | None
    author_id: int
    content: str
    image_url: str


class Reaction(Structure):
    post_id: int | None
    comment_id: int | None
    user_id: int
    react_emoji: str
```

Just one look at that should be giving you the heebie-jeebies: there's
so much room for invalid data! What if I set both `post_id` and `comment_id`?
Or neither? Sure, the app *right now* doesn't do that, but there's nothing
stopping an uninformed admin from manually inserting such invalid data, or
a little bug coming up that introduces hundreds of unattached comments.
Sure we could put some constraints in at the database level to make this work,
but those are hard to notice as a developer without access to the database, and
are prone to being forgotten when, say, we start allowing reactions to have
comments as well and a third foreign key appears.

Instead, if we had come at this problem from the data-side first (think,
database side first), we would likely have arrived at the much cleaner
structure:

```python
class Post(Structure):
    reply_to_id: int | None
    author_id: int
    content: str
    image_url: str


class Reaction(Structure):
    post_id: int | None
    user_id: int
    react_emoji: str
```

Comment has been done away with entirely, and instead comments are considered
to be "posts in reply to other posts".
