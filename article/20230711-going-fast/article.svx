---
title: Going Fast
subtitle: "There are no shortcuts"
date: 2023-07-11
tags:
- learning
author: Cam
---

Going fast often feels like a priority. It shouldn't be. As individual people we
should be looking to learn and build and explore, not "go fast". I suspect the
desire for speed mostly comes as a result of pressure from above: write more code
and finish more features, impress the boss and get promoted (or, just not get fired).

In daily working, going fast is not the goal. The actual goal is always to be learning,
growing, and improving. Before every task, take the time to think about what you're about
to do and plan it out. When you're done, take the time to look back and review what you
just built:
* Did you stick to the plan? What had to change and why? Make note, and learn from your experiences.
* Are there any pieces you are not satisfied with? Now is the best time to rewrite it, while you still remember what it's supposed to do.

If you keep doing that, the speed will come naturally. In my experience, it often takes
about the same amount of time as just rushing through anyway; the time spent planning
makes the implementation so much faster, and the time spent reviewing catches so many
bugs before they cause any issue, and gives you the chance to fix them while the code
is still fresh in your mind. Sure, you weren't writing code the whole time, but writing
code isn't the whole of coding.

Unfortunately, sometimes you do end up in situations where you just need it done **now**.
Personally, producing at top speed became, and continues to be, a priority at work for the
last little while. A situation caused by tight deadlines and a general short-staffedness
for the amount of stuff we are trying to release all at once. This is a situation that
I would not consider "daily working." The priorities really have changed.

Lucky for me, I've found some time to think about the last few weeks' work,
and about what worked and what didn't in this prolonged period of prioritizing speed.

### Manage assumptions

Probably the number one contributing factor to speed is being able to assume things
correctly. All code is full of rules and expectations so it makes sense that when
you know those rules, and know what you can expect, you can move much quicker. When
you know and understand the full extent of a system, you can move confidently making
the big and important changes while knowing that you won't break anything (or at least,
not break anything serious) because you know you didn't violate any of the big rules.

Conversely, every time you expect something and that expectation is incorrect, you end up
spending a lot of time debugging, and usually *not* in the code you were just working on.
The rule was broken somewhere else, without being detected, and so in order to fix it you
have to drop your context, climb out of the deep focus you were in, and sift through
unrelated cruft to find some arcane incantation that does not satisfy the unwritten rules.

The specific set of rules that you come up with for your projects will be subjective.
They'll probably also come up naturally and quietly without anyone ever mentioning them.
Sometimes you don't even realize that you've been making an assumption because it just
feels so natural. Only when you make a different assumption and it all starts to fall
apart do you notice, but by then it's too late.

To that end, the most important thing here is to *pay attention* to every assumption
you make. Get into the habit of watching for assumptions and invariants, and in particular
watching for the times you break those assumptions. Make this habit while working
at regular pace so that it's not something you have to think about when rushing; you
won't have time to think about anything that isn't already second nature.

On a regular day, paying attention to assumptions consists of:
* Identifying any deviations from the normal and marking them as such with inline comments.
* Documenting any major assumptions that are not testable (project structure, modularization policies, etc.).
* Writing unit tests for functions that you would like to assume continue to work as they are written.

All of those things take time, but when you have that time it's time well spent. When you
really do need to work fast, you may have to let up on the documentation and enforcement,
but you can't let up on the paying attention. It simply requires more discipline, from you
and from your team, to maintain these assumptions manually in the short term, until you
get the time to solidify them later.

Writing comments inline when you break assumptions doesn't really change when you're moving
fast, but writing unit tests and documenting assumptions each look pretty different from
normal.

### Communication

When moving fast, documentation becomes communication. Nothing beats the speed and clarity
of explaining something to someone face to face, in words. The option of bidirectional
communication makes understanding just that much easier. None of the involved parties will
have time to read documentation, so they won't, but it's easy to just ask and answer.

As the primary developer, the one who has written into the code a new assumption, make sure that
the assumption is communicated clearly to everyone who will need to know about it.

Transient documentation (i.e. just communication) is actually better in this case. Any long
written document will require constant updates and inevitably drift away from being accurate.
More often than not you'll have to rewrite the document before anyone has even read it, when
working on a feature all to yourself and making and changing the assumptions daily. Additionally,
once someone has read the long document, they aren't going to re-read it for changes every day;
they're just going to (incorrectly) remember what they read last time.

You're better off just mentioning it in some one off form, such as a comment on a PR or
a Slack message, or verbally during standup, and then clarifying and explaining on demand
when the need arises.

As the secondary developer, who is writing code to fit into a system written by someone else,
it's your responsibility to make sure you understand the assumptions previously made so as not
to cause trouble to the primary developer. Pay attention when they mention some assumption that
was made or changed; you don't have to understand it at that moment, but you do need to be aware
that there is an assumption and go hunt down the details when you need them. There is no shame
in asking for clarification. As the person the questions are often asked to, I find no inconvenience
in explaining what needs to be explained; rather that than have to debug someone else's code later.

In any case, the habit to make here is to aim for self documenting code, as well as to practice code
comprehension. In any time frame, to be able to read and understand code is a very important skill,
and only more so in fast times. Always take the time to really understand what you're doing and why,
it will always pay off, often even sooner than you expect.

### Unit tests

The purpose of unit tests, regularly, is to document and enforce assumptions: assumptions of
how the code is supposed to work, assumptions of what types of data are meant to be passed in
and what types of values will be returned. Regularly, they are also often used to ensure that
features work as intended, but when working fast, you simply don't have time to write tests
for everything. They say unit tests actually speed up development time, but that's only true
if you use them well. You need to be testing functions, but not features.

Treat unit tests as a tool that you can use to get your work done quickly and correctly, rather
than a task that must be completed. When it makes sense, prefer to write tests for individual
pieces of code rather than testing manually. Meanwhile, don't spend time after implementing a
whole feature writing tests to lock it in place. You don't have time for integration tests,
especially not when you're probably going to delete one of the integrated parts before long.

The result is that you'll have relatively few unit tests, and most of them will never fail,
but because you understand the assumptions and the system as a whole so well (right?) you can
be pretty sure that if all the parts are working, so is the whole thing.

### Delete fast

When writing fast, you are also deleting fast. On many occasions, I find myself deleting code
I wrote yesterday because we changed our direction overnight. In the three month lifespan of our
current project, we've re-architected and rewritten the entire thing three times. Not to
say that tests are to be skipped entirely, but there were at least a day's worth of tests that I
wrote and then deleted without ever coming close to changing their corresponding features.
